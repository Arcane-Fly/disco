#!/usr/bin/env node
/**
 * Railway Configuration Validation Report Generator
 * Generates comprehensive validation reports in markdown format
 */

const RailwayConfigValidator = require('./validator.cjs');
const EnvValidator = require('./env-validator.cjs');
const AuthValidator = require('./auth-validator.cjs');

class ReportGenerator {
  constructor(projectPath = '.') {
    this.projectPath = projectPath;
    this.results = {
      railway: null,
      env: null,
      auth: null
    };
  }

  /**
   * Generate comprehensive validation report
   */
  async generateReport() {
    console.log('📊 Generating Railway Configuration Validation Report...\n');
    
    try {
      // Run all validators
      await this.runValidators();
      
      // Generate markdown report
      const report = this.createMarkdownReport();
      
      console.log(report);
      return report;
    } catch (error) {
      console.error('❌ Report generation failed:', error.message);
      process.exit(1);
    }
  }

  /**
   * Run all validation modules
   */
  async runValidators() {
    // Railway configuration validation
    const railwayValidator = new RailwayConfigValidator(this.projectPath);
    try {
      await railwayValidator.validate();
      this.results.railway = railwayValidator.getResults();
    } catch (error) {
      this.results.railway = {
        errors: [`Validation failed: ${error.message}`],
        warnings: [],
        fixes: [],
        success: false
      };
    }

    // Environment variables validation
    const envValidator = new EnvValidator(this.projectPath);
    try {
      await envValidator.validate();
      this.results.env = envValidator.getResults();
    } catch (error) {
      this.results.env = {
        errors: [`Validation failed: ${error.message}`],
        warnings: [],
        fixes: [],
        success: false
      };
    }

    // Authentication validation
    const authValidator = new AuthValidator(this.projectPath);
    try {
      await authValidator.validate();
      this.results.auth = authValidator.getResults();
    } catch (error) {
      this.results.auth = {
        errors: [`Validation failed: ${error.message}`],
        warnings: [],
        fixes: [],
        success: false
      };
    }
  }

  /**
   * Create comprehensive markdown report
   */
  createMarkdownReport() {
    const timestamp = new Date().toISOString();
    const overallSuccess = this.results.railway.success && 
                          this.results.env.success && 
                          this.results.auth.success;
    
    let report = `# Railway Configuration Validation Report

**Generated:** ${timestamp}
**Status:** ${overallSuccess ? '✅ PASSED' : '❌ FAILED'}

---

## Executive Summary

${this.generateExecutiveSummary()}

---

## Railway Configuration Validation

${this.generateSectionReport(this.results.railway, 'Railway configuration')}

---

## Environment Variables Validation

${this.generateSectionReport(this.results.env, 'Environment variables')}

---

## Authentication & CORS Validation

${this.generateSectionReport(this.results.auth, 'Authentication and CORS')}

---

## Detailed Recommendations

${this.generateRecommendations()}

---

## Quick Fix Checklist

${this.generateQuickFixes()}

---

## Production Readiness Score

${this.generateReadinessScore()}

---

*Report generated by Railway Configuration Validation Agent*
`;

    return report;
  }

  /**
   * Generate executive summary
   */
  generateExecutiveSummary() {
    const totalErrors = this.getTotalCount('errors');
    const totalWarnings = this.getTotalCount('warnings');
    const totalFixes = this.getTotalCount('fixes');

    if (totalErrors === 0 && totalWarnings === 0) {
      return `🎉 **Excellent!** Your Railway configuration is production-ready with no issues detected.

All validation checks passed successfully:
- ✅ Railway configuration is properly structured
- ✅ Environment variables are correctly configured
- ✅ Authentication and CORS settings are secure`;
    }

    let summary = `📋 Configuration analysis completed with ${totalErrors} error(s) and ${totalWarnings} warning(s) detected.\n\n`;
    
    if (totalErrors > 0) {
      summary += `**Critical Issues:** ${totalErrors} error(s) must be resolved before deployment.\n`;
    }
    
    if (totalWarnings > 0) {
      summary += `**Recommendations:** ${totalWarnings} warning(s) should be addressed for optimal configuration.\n`;
    }
    
    if (totalFixes > 0) {
      summary += `**Action Items:** ${totalFixes} suggested fix(es) available below.\n`;
    }

    return summary;
  }

  /**
   * Generate section report
   */
  generateSectionReport(results, sectionName) {
    if (!results) {
      return `❌ ${sectionName} validation failed to run`;
    }

    let section = `**Status:** ${results.success ? '✅ PASSED' : '❌ FAILED'}\n\n`;

    if (results.errors && results.errors.length > 0) {
      section += `### ❌ Errors (${results.errors.length})\n\n`;
      results.errors.forEach((error, index) => {
        section += `${index + 1}. ${error}\n`;
      });
      section += '\n';
    }

    if (results.warnings && results.warnings.length > 0) {
      section += `### ⚠️ Warnings (${results.warnings.length})\n\n`;
      results.warnings.forEach((warning, index) => {
        section += `${index + 1}. ${warning}\n`;
      });
      section += '\n';
    }

    if (results.success && (!results.errors || results.errors.length === 0) && (!results.warnings || results.warnings.length === 0)) {
      section += `✅ All ${sectionName} checks passed successfully.\n\n`;
    }

    return section;
  }

  /**
   * Generate recommendations section
   */
  generateRecommendations() {
    let recommendations = '';

    // High priority recommendations
    const criticalErrors = this.getAllErrors();
    if (criticalErrors.length > 0) {
      recommendations += `### 🚨 Critical Issues (Must Fix)\n\n`;
      criticalErrors.forEach((error, index) => {
        recommendations += `${index + 1}. **${error}**\n`;
      });
      recommendations += '\n';
    }

    // Security recommendations
    const securityWarnings = this.getSecurityWarnings();
    if (securityWarnings.length > 0) {
      recommendations += `### 🔒 Security Recommendations\n\n`;
      securityWarnings.forEach((warning, index) => {
        recommendations += `${index + 1}. ${warning}\n`;
      });
      recommendations += '\n';
    }

    // Performance recommendations
    const performanceWarnings = this.getPerformanceWarnings();
    if (performanceWarnings.length > 0) {
      recommendations += `### ⚡ Performance Recommendations\n\n`;
      performanceWarnings.forEach((warning, index) => {
        recommendations += `${index + 1}. ${warning}\n`;
      });
      recommendations += '\n';
    }

    if (recommendations === '') {
      recommendations = '🎉 No specific recommendations - your configuration looks great!';
    }

    return recommendations;
  }

  /**
   * Generate quick fixes checklist
   */
  generateQuickFixes() {
    const allFixes = this.getAllFixes();
    
    if (allFixes.length === 0) {
      return '🎉 No fixes needed - your configuration is ready to deploy!';
    }

    let checklist = '';
    allFixes.forEach((fix, index) => {
      checklist += `- [ ] ${fix}\n`;
    });

    return checklist;
  }

  /**
   * Generate production readiness score
   */
  generateReadinessScore() {
    const totalErrors = this.getTotalCount('errors');
    const totalWarnings = this.getTotalCount('warnings');
    
    let score = 100;
    score -= totalErrors * 20; // Each error reduces score by 20
    score -= totalWarnings * 5; // Each warning reduces score by 5
    score = Math.max(0, score);

    let status = '';
    if (score >= 90) {
      status = '🟢 Excellent - Production Ready';
    } else if (score >= 70) {
      status = '🟡 Good - Minor improvements recommended';
    } else if (score >= 50) {
      status = '🟠 Fair - Several issues need attention';
    } else {
      status = '🔴 Poor - Critical issues must be resolved';
    }

    return `**Score: ${score}/100**

${status}

### Scoring Breakdown:
- Base Score: 100
- Errors: -${totalErrors * 20} (${totalErrors} × 20 points)
- Warnings: -${totalWarnings * 5} (${totalWarnings} × 5 points)

### Next Steps:
${score < 70 ? '1. 🔥 **Priority:** Fix all critical errors first\n2. 📋 Address warnings for optimal configuration\n3. 🚀 Re-run validation after fixes' : '1. ✅ Configuration is ready for production deployment\n2. 📈 Consider addressing warnings for perfection\n3. 🎉 Deploy with confidence!'}`;
  }

  /**
   * Helper methods
   */
  getTotalCount(type) {
    return Object.values(this.results).reduce((total, result) => {
      return total + (result && result[type] ? result[type].length : 0);
    }, 0);
  }

  getAllErrors() {
    const errors = [];
    Object.values(this.results).forEach(result => {
      if (result && result.errors) {
        errors.push(...result.errors);
      }
    });
    return errors;
  }

  getAllFixes() {
    const fixes = [];
    Object.values(this.results).forEach(result => {
      if (result && result.fixes) {
        fixes.push(...result.fixes);
      }
    });
    return fixes;
  }

  getSecurityWarnings() {
    const securityKeywords = ['security', 'secret', 'password', 'cors', 'origin', 'auth', 'jwt', 'oauth'];
    return this.getWarningsByKeywords(securityKeywords);
  }

  getPerformanceWarnings() {
    const performanceKeywords = ['cache', 'build', 'optimization', 'memory', 'timeout'];
    return this.getWarningsByKeywords(performanceKeywords);
  }

  getWarningsByKeywords(keywords) {
    const warnings = [];
    Object.values(this.results).forEach(result => {
      if (result && result.warnings) {
        const filtered = result.warnings.filter(warning => 
          keywords.some(keyword => warning.toLowerCase().includes(keyword))
        );
        warnings.push(...filtered);
      }
    });
    return warnings;
  }
}

// Run report generation if called directly
if (require.main === module) {
  const generator = new ReportGenerator();
  generator.generateReport().catch(error => {
    console.error('❌ Report generation failed:', error);
    process.exit(1);
  });
}

module.exports = ReportGenerator;